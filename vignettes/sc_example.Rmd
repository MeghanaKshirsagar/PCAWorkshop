---
title: 'PCA example: scRNAseq'
author: "Lauren Hsu"
date: "7/16/2020"
output:
  rmarkdown::html_document:
    highlight: pygments
    toc: true
    toc_depth: 3
    fig_width: 5
bibliography: ref.bib
vignette: >
  %\VignetteIndexEntry{PCA example: scRNAseq}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding[utf8]{inputenc}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

Single-cell â€™omics analysis enables high-resolution characterization of heterogeneous populations of cells by quantifying measurements in individual cells and thus provides a fuller, more nuanced picture into the complexity and heterogeneity between cells. However, the data also present new and significant challenges as compared to previous approaches, especially as single-cell data are much larger and sparser than data generated from bulk sequencing methods. Dimensionality reduction is a key step in the single-cell analysis to address the high dimensionality and sparsity of these data, and to enable the application of more complex, computationally expensive downstream pipelines.

In this example, we will use the `Zhengmix4eq` benchmarking dataset from the [`DuoClustering2018`](https://bioconductor.org/packages/release/data/experiment/html/DuoClustering2018.html) package.

```{r, message = F}
library(SingleCellExperiment)
library(corral)
library(ggplot2)

library(DuoClustering2018)
zm4eq.sce <- sce_full_Zhengmix4eq()
```

The data loads as a [`SingleCellExperiment`](https://bioconductor.org/packages/release/bioc/html/SingleCellExperiment.html) object:

```{r}
zm4eq.sce
```

We'll use `assay` to access the count and logcount matrices. The genes are in the rows, and the cells are in the columns.

```{r}
counts_mat <- assay(zm4eq.sce, 'counts')
logcounts_mat <- assay(zm4eq.sce, 'logcounts')
```

`colData` and `rowData` contain (and can be used to access) the cell and gene metadata, respectively. 

```{r}
head(colData(zm4eq.sce))
head(rowData(zm4eq.sce))
```

This dataset includes approximately 4,000 pre-sorted and annotated cells of 
4 types mixed by Duo et al. in approximately equal proportions [@zmdata]. 
The cells were sampled from a "Massively parallel digital transcriptional 
profiling of single cells" [@zheng].

```{r}
table(zm4eq.sce$phenoid) # the $ operator can be used to access columns in colData
```

For each of the 4,000 cells, there are counts for over 15,000 genes.

```{r}
dim(counts_mat)
```

When examining a dataset like this, we might be interested in understanding more about the cells -- for example, how many clusters are there and what are the cell types? 

We might also be interested in understanding the features themselves, perhaps to identify from the 15,000 genes those that are associated wth particular clusters.

Matrix factorization methods like PCA enable us to look at both "row" and "column" associations.

## PCA

First, we will select features with a simple, crude approach -- we'll sort the genes by variance, then select the 500 genes with highest variance. Selecting variable genes will improve the signal to noise ratio. Moreover, from a practical perspective, this will reduce the dataset size so that analysis steps will be computationally tractable. (Typically, in actual analysis pipelines, selection of highly variable genes (HVGs) uses a mean-variance stabilization, for example as in the `scran` package, or in the `Seurat` packages. This is because there is a relationship between the mean and the variance of the features. See the [*Orchestrating Single Cell Analysis*](https://osca.bioconductor.org/feature-selection.html) book for more discussion on feature selection approaches.)

```{r}
gene_vars <- apply(logcounts_mat, FUN = var, MARGIN = 1)
gene_vars <- sort(gene_vars, decreasing = T)

counts_mat <- counts_mat[names(gene_vars[1:500]),]
logcounts_mat <- logcounts_mat[names(gene_vars[1:500]),]
```

We will start by using `prcomp` to perform PCA on the counts and the logcounts, which will find cell embeddings in a lower dimensional space.

For purposes of comparison later, we'll also record the runtime.

```{r}
prc_time <- system.time(counts_prc <- prcomp(counts_mat))
logcounts_prc <- prcomp(logcounts_mat)
```

We'll use the `plot_embedding` function from the `corral` package to plot the cell embeddings:

```{r}
plot_embedding(counts_prc$rotation, 
               xpc = 1, 
               plot_title = 'PCA on counts', 
               color_vec = zm4eq.sce$phenoid, 
               color_title = 'Cell type', 
               saveplot = F)

plot_embedding(logcounts_prc$rotation, 
               xpc = 1,
               plot_title = 'PCA on logcounts', 
               color_vec = zm4eq.sce$phenoid, 
               color_title = 'Cell type', 
               saveplot = F)
```

These examples illustrate the importance of performing pre-processing -- when PCA is performed on raw counts, we see an arch effect. In contrast, when performed on log-transformed counts, there is no arch effect. See our recent [mini-review article](https://www.frontiersin.org/articles/10.3389/fonc.2020.00973/full) in *Frontiers in Oncology* for further discussion of data pre-processing and transformations [@frontiers].

### *Interactive example 1*

On the count data, the first two PCs contain a strong arch effect. On both plots, use the `xpc` argument in the plotting function to change which PC you're looking at. What do the 2nd and 3rd PCs of the **PCA on counts** plot look like?

```{r}
plot_embedding(counts_prc$rotation, 
               xpc = 1, 
               plot_title = 'PCA on counts', 
               color_vec = zm4eq.sce$phenoid, 
               color_title = 'Cell type', 
               saveplot = F)

plot_embedding(logcounts_prc$rotation, 
               xpc = 1,
               plot_title = 'PCA on logcounts', 
               color_vec = zm4eq.sce$phenoid, 
               color_title = 'Cell type', 
               saveplot = F)
```

Perform the equivalent PCA without using `prcomp`.

```{r}
# your code here
```

## Visualizing embeddings

While we can browse the PCs For purposes of visualization and other analyses like clustering, UMAP and tsne 

```{r}

```



## Speeding up PCA

This dataset is small compared to many that we encounter in biology. 

```{r}

```

As we saw above, we can achieve the same results as a `prcomp` call by using the `scale` and `svd` function.

Similarly, 

### *Interactive example 2*

Perform PCA on 

```{r}
# time comparison prcomp, scale+svd, scale+irlba
```


## Brief introduction to correspondence analysis

PCA is the oldest dimension reduction method, and while it is popular, it is only one of many possible methods; there are numerous methods related to PCA. One such method is **correspondence analysis (CA)**, which is similar to PCA.

Instead of a centering or z-score transformation as in PCA, CA applies a $\chi^2$ transformation prior to performing SVD, and is appropriate for use with count data. It is popular in other fields, such as ecology, business research, and archaeology, for finding associations between rows and columns.

Correspondence analysis is implemented in various R packages, including:

- `ade4`::`dudi.coa()`
- `made4`::`ord(type = 'coa')`
- `vegan`::`cca()` *(not to be confused with canonical correlation analysis, also abbreviated CCA)*
- `FactoMineR`::`CA()`

However, these implementations are not designed for very large data, and thus are unwieldy for single-cell analysis. To enable the fast (and easy) application of CA to such datasets, we developed the `corral` package.

[![](corral_sticker.png){ width=10% }](https://www.bioconductor.org/packages/devel/bioc/html/corral.html)

`corral`::`corral` performs correspondence analysis:

```{r}

```

### *Interactive example 3*

Load another scRNAseq benchmarking dataset from the `DuoClustering2018` package and compare the results from using different dimension reduction methods.

```{r}

```





